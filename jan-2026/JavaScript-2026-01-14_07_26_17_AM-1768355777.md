# Interview Question – Promise.allSettled & async/await

## Question

Consider the following asynchronous JavaScript code.

What will be logged to the console when `processData()` is executed, and **why does the `catch` block never run**?

---

## Code Snippet

```js
async function processData() {
  const promise1 = Promise.resolve('first');
  const promise2 = Promise.reject('error');
  const promise3 = Promise.resolve('third');

  try {
    const result = await Promise.allSettled([promise1, promise2, promise3]);
    console.log(result[0].status);
    console.log(result[1].reason);
    console.log(result[2].value);
  } catch (error) {
    console.log('caught:', error);
  }

  try {
    const result = await Promise.allSettled([promise1, promise2, promise3]);
    console.log(result[0]);
    console.log(result[1]);
    console.log(result[2]);
  } catch (error) {
    console.log('caught:', error);
  }
}

processData();
```

---

## Answer

### Console Output

```js
fulfilled
error
third
{ status: 'fulfilled', value: 'first' }
{ status: 'rejected', reason: 'error' }
{ status: 'fulfilled', value: 'third' }
```

---

## Explanation (Interview-Friendly)

- `Promise.allSettled()` **never rejects**
- It always resolves with an array describing the result of **each promise**
- Each item contains:

  - `status: "fulfilled"` with `value`
  - `status: "rejected"` with `reason`

### Why `catch` is NOT executed

- Even though `promise2` is rejected,
- `Promise.allSettled()` **handles the rejection internally**
- Therefore, no error is thrown and `catch` is skipped

---

## Key Interview Takeaway

| Method                 | Behavior on Rejection    |
| ---------------------- | ------------------------ |
| `Promise.all()`        | ❌ Rejects immediately   |
| `Promise.allSettled()` | ✅ Always resolves       |
| `Promise.any()`        | Rejects only if all fail |
| `Promise.race()`       | Settles on first promise |

---

## Bonus Interview Tip

Use **`Promise.allSettled()`** when:

- You need results from **all promises**
- Failures should **not stop execution**
